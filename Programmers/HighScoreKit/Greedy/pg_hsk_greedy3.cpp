/*
큰 수 만들기
https://programmers.co.kr/learn/courses/30/lessons/42883

?:
어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.
예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.
문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. 
number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

!!!:
number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.
k는 1 이상 number의 자릿수 미만인 자연수입니다.

시도1)
우선 이 문제가 greedy문제임을 눈치채야한다.
입력의 크기가 100만까지 가능한데
k개를 제거했을 때 얻을 수 있는 모든 가지수를 고려하여 풀면 시간이 남을리가 없다.
즉, 정답을 한번에 찾는 알고리즘을 작성해야한다.

앞자리수 중 작은 값이 삭제되는 것이 숫자의 크기에 영향을 제일 많이 주게된다는 점을 착안하면, 
앞에서부터 시작하여 바로 뒤의 자리수보다 앞의 자리수가 작으면 앞자리 수를 삭제하는 식으로 진행하면된다.
만일 앞에서 부터 진행하는데 모든 수가 내림차순으로 정렬되어 있었다면,
맨 뒤에 수가 삭제되면 제일 큰 수가된다.

시도2)
시간초과가 발생했다.
시간초과가 발생 가능한 경우는 내림차순으로 정렬된 큰 입력이 들어온 경우를 생각할 수 있다.
이 경우를 해결하기 위해선
이전에 삭제한 경우가 젤 뒤에 값을 삭제한 경우 이번에 삭제할 때도 젤뒤에서 삭제한다.(이미 내림차순 정렬된 상태라는 뜻이기 때문)

시도3)
그래도 시간초과가 발생한다...
99999999999999...88888888888888...77777777... ... ... 111111...123456789 이런 입력이 들어온 경우를 생각해 볼 수 있다.
다음에 시작할 때 이전에 위치를 저장해놓고 거기서 부터 시작하도록 변경했다 --> (X) 완전히 내림차순 정렬된 경우가 아니면 성립하지 않는다.

시도4)
if문이 실패한 경우에는 정렬되어 있었다는 것으로 볼 수 있기 때문에
그때까지의 j를 저장하도록 else문에서 저장하도록 변경
--> 시간초과는 안뜨는데 실패한다. j의 index를 조정해봐야 겠다.

시도5)
j의 시작은 0부터 하는게 맞다.(남은게 내림차순이 아닌 이상)
여기가 문제가 아니라, 문자열을 substr으로 매번 다시 만드는게 문자열 크기가 커지면 시간초과가 나는 원인이 되는 것 같다.
그래서 이번에는 매번 삭제한 후 새로 문자열을 만들지 않고 삭제한 위치를 따로 표시한 다음 건너 뛰고 비교하도록 바꿔보았다.
많은 변경이 발생할 것 같아서 새 파일에 작성했다.

시도6) 아직도 10번에서 시간초과 된다...
도저히 모르겠어서 이전에 통과했던 것 시도해봤는데 이번엔 통과 안됐다.
힌트 살펴본 결과 앞자리가 9가 나오면 이 숫자가 삭제될 일은 없다.
즉, 9가 나온 경우는 바로 다음 숫자를 보도록 처리하면된다고한다...
*/

#include <string>
#include <vector>
#include <iostream>

using namespace std;

string solution(string number, int k) {
    string answer = "";
    bool isDecreasing = false;

    // k회 삭제를 수행
    for(int i=0; i<k; ++i)
    {
        int j;    // 시도3) 앞은 내림차순으로 정렬된 상태일 것이므로 이전 위치부터 고려한다.
        int N = number.size();
        if(isDecreasing)    // 시도2) 이미 내림차순 정렬되어 있는 경우 바로 뒤에서 부터 삭제
        {
            // 다 내림차순인 경우 맨 뒤를 삭제
            number = number.substr(0, N-1);
            continue;
        }
        for(j=0; j<N-1; ++j)
        {
            if(number[j] == '9')
                continue;   // 앞자리 9인 경우가 삭제될 상황은 9999... 이외엔 발생하지 않는다

            // 뒤에 값보다 앞에 값이 작으면
            if(number[j] < number[j+1])
            {   // 앞에값 삭제 number[j] 제외한 부분 문자열을 만든뒤 다시 합친다
                string front = number.substr(0, j); // 2번째 인자 자리는 cnt이고 j는 index이기 때문에 substr(0,j)에 number[j]는 포함되지 않는다
                string back = number.substr(j+1, N-(j+1));  // 시작위치는 포함된다(j+1), 여기서 부터 끝까지 세려면 원본 길이(N)-front의 길이-삭제된 number[j]길이(1)
                // 즉, N-j-1 --> N-(j+1)로 나타낼 수 있다
                number = front+back;
                break;
            }
        }
        if(j == N-1)
        {   // 다 내림차순인 경우 맨 뒤를 삭제
            number = number.substr(0, N-1);
            isDecreasing = true;
        }
    }
    answer = number;

    return answer;
}

int main()
{
    string number = "4177252841";
    int k = 9;

    cout << solution(number, k) << endl;

    return 0;
}