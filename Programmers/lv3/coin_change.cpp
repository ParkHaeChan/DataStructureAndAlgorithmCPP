/*
거스름돈
https://programmers.co.kr/learn/courses/30/lessons/12907

Finn은 편의점에서 야간 아르바이트를 하고 있습니다. 야간에 손님이 너무 없어 심심한 Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다.

예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다.

1원을 5개 사용해서 거슬러 준다.
1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다.
1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다.
5원을 1개 사용해서 거슬러 준다.
거슬러 줘야 하는 금액 n과 Finn이 현재 보유하고 있는 돈의 종류 money가 매개변수로 주어질 때, Finn이 n 원을 거슬러 줄 방법의 수를 return 하도록 solution 함수를 완성해 주세요.

제한 사항
n은 100,000 이하의 자연수입니다.
화폐 단위는 100종류 이하입니다.
모든 화폐는 무한하게 있다고 가정합니다.
정답이 커질 수 있으니, 1,000,000,007로 나눈 나머지를 return 해주세요.

시도1)
경우의 수를 다루는 문제는 대게 동적계획법 문제를 의심해 볼 수 있다.
바로 동적 계획법으로 가능한지 확인해본다.

1,2,5원을 사용하여 n원을 거슬러 주는 가짓수 =
1원 하나 사용하고 나머지 n-1원을 거슬러 주는 방법, 2원하나 사용하고 n-2원 거슬러 주는 방법, 5원 하나 사용하고 n-5원 거슬러 주는 방법...
의 합으로 구할 수 있다.

시도2)
뭔가 안맞아서 다시 생각했다. 동전 가지수가 100개인걸 봐서 DP tabledmf 2차원 배열 DP[n][m]으로 구성해서
DP[n][m]: n원을 m번째 동전 이하를 모두 사용하여 구성하는 경우로 정의하고 시도하려했다가 잘 안됨

시도3)
해설을 참고했다.
m번째 동전으로 구성가능한 모든 n원을 만들어 본다. 이떄 DP[0] = 1로 두면 i-money[m] == 0 인 경우를 처리하기 쉬워진다.
반복문도 money에 대해서 먼저 수행후 내부에서 n원이 계산되는지 확인해보는 식으로 진행한다.
*/

#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int solution(int n, vector<int> money) {
    int answer = 0;
    const int DIV = 1000000007;
    int M = money.size();
    vector<int> DP(n+1, 0);
    DP[0] = 1;      // i-money[m]이 0인 경우 계산을 쉽게 처리하기 위해 놓은 장치
    
    // m번째 동전으로 n원 이내를 구성하는 모든 경우를 미리 구한다
    for(int m=0; m<M; ++m)
    {
        for(int i=1; i<=n; ++i)
        {
            if(i - money[m] >= 0)
            {
                DP[i] = (DP[i]%DIV + DP[i-money[m]]%DIV)%DIV;
            }
        }
    }
    return answer = DP[n];
}

int main()
{
    int n = 10;
    vector<int> money = {1,2,5};

    solution(n, money);

    return 0;
}