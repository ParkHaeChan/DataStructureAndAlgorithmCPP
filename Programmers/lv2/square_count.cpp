/*
멀쩡한 사각형
https://programmers.co.kr/learn/courses/30/lessons/62048

가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 
모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 
누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 
새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다.
가로의 길이 W와 세로의 길이 H가 주어질 때, 사용할 수 있는 정사각형의 개수를 구하는 solution 함수를 완성해 주세요.

!!!:
W, H : 1억 이하의 자연수

가로가 8, 세로가 12인 직사각형을 대각선 방향으로 자르면 총 16개 정사각형을 사용할 수 없게 됩니다. 
원래 직사각형에서는 96개의 정사각형을 만들 수 있었으므로, 96 - 16 = 80 을 반환합니다.

전체 사각형 수는 곱셈으로 바로 계산할 수 있고, 대각선 잘리는 것을 시뮬레이션하는 문제이다.
바로 떠오르는 방식은 대각선 직선에 대한 방정식과 각 사각형의 변에 대해서 교점이 있는지 확인하는 방식이 떠오른다.
그림을 살펴보면 구간에 걸치는 경우가 있고 구간의 시작점에 일치하는 경우가 있다. 그때마다 삭제되는 사각형의 수가 결정된다고 볼 수 있다.
처음 시작위치는 무조건 잘리고, 그 옆이 잘리는지를 직선방정식에 대입해서 여부를 판단하는 식으로 작성해본다.

시도1) 실패: 기울기로 한 다음 ceil하면 기울기가 (0~1사이로 나올때 0이 되는 문제가 생긴다)
시도2) 실패: 안되는 케이스에 대한 고찰이 필요한 듯함.
h < w 이면 swap하고, w/gcd인 케이스를 일일이 x값 1씩 증가시켜보며 걸치는 y값 세도록 조정
diff에는 ceil 적용하고 last에는 floor 적용하도록 해봄
시도3) 실패: 점수 약간 오름(61) 이외에도 안되는 케이스가 존재함
lround 적용해 봤으나 변화 없는 걸로 봐선 형변환에서 생긴 문제는 아닌듯 함, double을 long double형으로 바꿔도 마찬가지

시도4) 힌트 참고하였음
<case 별 해법>
6번:  case통과 안되는 부분: diff = (double)(h/gcd)/(w/gcd)*x; 이부분을 곱셈을 먼저하도록 변경하여
오차가 적게 발생하도록 조치(기울기 구한답시고 소수점 계산을 먼저한 다음 x 곱하면 오차가 발생하게 된다)
12~17번: 자료형 제한 범위로 인해 발생한다함...answer 초기화 할 때 그냥 w*h 쓴 곳이 문제였음
(참고: ceil, floor에 (long double이 반환형이다) lround 안써도 통과됨 하지만 c++ 버전이나 컴파일러 차이일 수도 있으므로 찝찝하면 쓰자)

문제 접근 자체는 잘했는데 큰 수 자료형 다루는데서 많이 해매서 거의 1시간 이상 방황함.
큰 수 계산을 요구하면 파이썬으로 푸는게 마음 편할 수도...
*/

#include <iostream>
#include <cmath>

using namespace std;

int GCD(int a, int b)
{
    if(a < b)
        swap(a, b);

    while(b != 0)
    {
        int temp = b;
        b = a%b;
        a = temp;
    }
    return a;
}

long long solution(int w,int h) {
    // 원래 사각형 개수
    long long answer = (long long)w*h;  // 주의!!!: 우변식이 int*int 이므로 형변환 후 대입해야 된다

    // 삭제되는 사각형 개수
    long long deleted = 0;
   
    // gcd만큼 반복된다
    int gcd = GCD(w, h);
    // 시도2: 기울기가 1 이상으로만 나오도록 조치(0~1사이로 나와도 대칭성 이용하면 같음)
    if(h < w)
        swap(h, w);
    long double diff;
    long double last = 0;
    for(int x=1; x<= (w/gcd); ++x)
    {   // 주의!!!: (곱셈과 나눗셈을 적절히 분배하여 (1미만소수점)*(큰 수) 연산이 발생하지 않도록 조치해야 오차 문제가 덜 발생한다)
        diff = (double)(h/gcd)*x/(w/gcd);   // 기울기 * x : 단, 위의 주의사항을 지키도록 순서 조정
        long long up = lround(ceil(diff));
        long long down = lround(floor(last));
        deleted += up-down;
        last = diff;
    }

    answer -= deleted*gcd;

    return answer;
}

int main()
{
    int w=8, h=12;

    cout << solution(w, h);

    return 0;
}