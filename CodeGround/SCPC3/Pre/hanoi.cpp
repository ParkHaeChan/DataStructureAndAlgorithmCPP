/*
그냥 재귀로 푸는 하노이 탑과는 매우 다르다.
접근 자체와 이해해야되는 난이도도 매우 다른 듯...

A에 있는 원판을 B로 옮기는 것은 같은데, 옮길 때 A->B, B->C, C->A로만 옮길 수 있다는 제한이 있다.(근데 이게 동시에 힌트가 된다...)
주어진 입력이 최적의 과정 중에 나올 수 있는 상태인가를 판단해야 한다.
N은 최대 100만이므로 모든 과정을 시뮬레이션하여서는 시간내에 풀 수 없다.
즉, 입력을 순서대로 확인하면서 최적의 상태로 이동중이였는지를 판단해야한다.
일단 3개짜리 입력을 직접 수행해 보면서 특징을 살펴본 결과,
젤 큰 원판이 C에 있으면 이것은 무적권! 최적의 경로로 간것이 아니다는 것은 쉽게 알 수 있다. <여기서 부터 입력을 거꾸로 봐야하는 문제인 것을 Catch한다>.

이외의 경우인 젤 큰 원판이 A 나 B에 있을 경우는 다음으로 큰 원판들의 위치가 최적의 경로로 이동중이었는지를 판단해야 한다.
나머지 원판들이 최적의 방식으로 이동한다고 생각하면,
젤 큰 원판이 아직 A에 있으면, 젤 큰 원판을 A에서 B로 옮기기 위해 나머지 원판들은 A에서 (B를 거쳐) C로 옮겨져야 하는 상황 중에 있어야 하고,
젤 큰 원판이 이미 B에 있으면, (최적의 방식으로 이동했다면 나머지 원판들은 이미 모두 C로 옮겨 졌고) C에서 (A를 거쳐) 다시 최종 목적지인 B로 옮겨지는 상황 중에 있어야 할 것이다.

이게 젤 큰 원판(now: index 끝번) 부터 그 다음으로 큰 원판 ... 이런식으로 가면서 비교되어야 하고,
3개의 봉 A,B,C를 각각 0, 1, 2로 대치하여 생각하면, 초기 상태를 (from, to, mid)로 두고 (0,1,2)로 시작한다.

이떄, 우리는 초기 조건으로 A->B, B->C, C->A 로의 이동만 가능하다는 조건이 있었다.
이는 바로 옆으로 한 칸씩만(단, C->A는 순환으로 처리한다고 봄) 이동할 수 있다고 보면 되므로
from에서 to로 갈 때 (from + 1) % 3 으로만 이동할 수 있다는 것을 뜻한다.

==현재 원판이 (from + 1) % 3 == to 로 목적지를 갈 수 있는 상황이라면,
input[now] == 'A' + (현재 상황) 으로 현재 원판을 확인해 보고 일치하면, 다음 상황 처리를 위해 목적지를 적절히 변경해 준다.
(현재 상황)에 들어갈 수 있는 것으로는: from, to, mid가 있다.
(현재 상황)이 from일 때와 일치한다면 아직 안옮겨진 상태이므로 가능한 상태이고, 나머지 원판들은 현재 from에 있는 젤 큰 원판을 to로 옮기기 위해 위에 모두 mid로 옮겨져야 한다.
즉, 목적지가 mid로 바뀌어야 하므로 swap(to, mid)
ex) 젤큰 원판이 A에 있고 (0,1,2) -> 다음 원판들은 B를 거쳐 C로 이동해야하는 상황 (0, 2, 1)
(현재 상황)이 to일 때와 일치한다면 이미 옮겨진 상태이므로 가능한 상태이고, 젤 큰 원판이 이미 목적지에 있다면 최적의 방식으로 이동한 경우
다음 원판들은 이미 mid에 도착한 상태이고 (from을 거쳐) to로 옮겨지는 상황이어야 한다.
즉, 목적지는 그대로이고 시작점과 거치는 지점이 바뀌어야 하므로 swap(from, mid)
ex) 젤큰 원판이 B에 있고 (0,1,2) -> 다음 원판들은 C에 있고 (A를 거쳐) 최종 목적지인 B로 이동해야하는 상황 (2, 1, 0)
(현재 상황)이 mid일 때와 일치한다면 최적의 경우로 이동했다면 불가능한 상태이다. 즉, <false 확정>
ex) 젤큰 원판이 C에 있고 (0,1,2) -> 현재 C에 있다: B(목적지)에 있었는데 넘어갔다 -> 최적X


==현재 원판이 (from + 1) % 3 == to 가 <아니면> 위 경우가 한번 진행되어서 (0,2,1) 또는 (2,1,0) 인 상태일 것이다.
<주의: (2,1,0)도 2 다음 0이 원래 수순이라 from+1%3으로 불가능한 경우임>
(현재 상황)이 from일 때와 일치한다면 아직 안옮겨진 상태이므로 가능한 상태이다. 다음 원판도 같은 조건으로 이동해야 하므로 목적지를 그대로 둬야 한다. swap(X)
(현재 상황)이 to일 때와 일치한다면 이미 옮겨진 상태이므로 가능한 상태이다. 다음 원판도 같은 조건으로 이동해야 하므로 그대로 둔다. swap(X)
(현재 상황)이 mid일 때와 일치한다면 다음 원판이 자리를 비켜줘야 하는 상황이므로 swap(from, to)가 필요하다. <이는 실제 상황을 봐야 이해가 간다>
---------------------------------------------------------------------------------------------
현재 (0,2,1) 이라면, 이전 원판이 최대이고, 아직 A에 있는 상태였다는 말이므로
ex) 이번 원판이 A(0)에 있고 (0,2,1) -> 아직 안옮겨진 상태: 다음 원판도 A->C로 이동하는 상태여야 하므로 그대로 설정
ex) 이번 원판이 B(1)에 있고 (0,2,1) -> 다음 원판은 최적으로 수행되었다면 C-> A로 이동하는 상황이어야 함. swap(from, to) -> (2,0,1)
ex) 이번 원판이 C(2)에 있고 (0,2,1) -> 이미 옮겨진 상태: 다음 원판도 A->C로 이동하는 상태여야 하므로 그대로 설정
---------------------------------------------------------------------------------------------
현재 (2,1,0) 이라면, 이전 원판이 최대이고, 이미 B에 있는 상태였다는 말이므로
ex) 이번 원판이 A(0)에 있고 (2,1,0) -> 다음 원판은 최적으로 수행되었다면 B->C로 이동하는 상황이어야 함. swap(from, to) -> (1,2,0)
ex) 이번 원판이 B(1)에 있고 (2,1,0) -> 이미 옮겨진 상태: 다음 원판도 C->B로 이동하는 상태여야 하므로 그대로 설정
ex) 이번 원판이 C(2)에 있고 (2,1,0) -> 아직 안옮겨진 상태: 다음 원판도 C->B로 이동하는 상태야야 하므로 그대로 설정
-------------------------------------------------------------------------------------------------------------------

여기서 swap이 발생하면 다시 (from + 1) % 3 == to 조건을 만족하는 경우가 되고(반복) 입력의 거꾸로 진행하면서 0번 index까지 확인하면 된다.
*/

#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

string Answer;
string input;

bool hanoi(int from, int to, int mid, int n)
{   // 젤 큰 원판부터 거꾸로 보면서 가능한 최적의 경로였는지 확인
    while(n > 0)
    {
        int now = n-1;
        if((from + 1)%3 == to)  // 1회 이동으로 목적지에 도달 가능한 상황
        {
            if(input[now] == 'A'+to)
            {   // 이미 목적지인 경우
                swap(from, mid);    // 다음 원판의 목적지 변경
                n--;
            }
            else if(input[now] == 'A'+from)
            {   // 아직 시작위치인 경우
                swap(to, mid);
                n--;
            }
            else
            {   // 최적으로 이동했다면 불가능한 경우
                return false;
            }
        }
        else
        {   // mid인 경우에 swap 발생
            if(input[now] == 'A' + mid)
            {
                swap(from, to);
                n--;
            }
            else    // 이외는 그대로 진행
                n--;
        }
    }
    return true;
}

int main(int argc, char** argv)
{
	int T, test_case;

	freopen("input1.txt", "r", stdin);

	cin >> T;
	for(test_case = 0; test_case  < T; test_case++)
	{
        int N;  // input string length
        cin >> N;
        cin >> input;
		
        Answer = (hanoi(0,1,2,N) ? "YES" : "NO");
		
		// Print the answer to standard output(screen).
		cout << "Case #" << test_case+1 << endl;
		cout << Answer << endl;
	}

	return 0;//Your program should return 0 on normal termination.
}